#!/usr/bin/env python3

__VERSION__ = (1, 0, 2)
__VERSION_STRING__ = '.'.join(str(v) for v in __VERSION__)


import sys
import argparse
import traceback

import pydbvolve


if __name__ == '__main__':
    def init_args():
        """Initialize argument parser. Returns argparse.ArgumentParser instance."""
        
        description = "Apply migrations to a database. "
        description += "Be careful!! This script will happily run *any* migration code you are able to with "
        description += "your database user's permissions! Make sure that you have tested backup and recovery "
        description += "procedures in place before using this script. Migration scripts are matched by version. "
        description += "Only SQL (.sql) and Python (.py) migration scripts are supported."
        
        parser = argparse.ArgumentParser(description=description)
        parser.add_argument("--config",             dest="configFileName",    metavar="CONF_FILE",  required=True,  help="Config code file")
        parser.add_argument("--force",              dest="sequential",        action="store_false",                 help="Apply version directly (no sequential iteration through versions)", default=True)
        parser.add_argument("--verbose",            dest="verbose",           action="store_true",                  help="Verbose mode (Echo log to screen; Show tracebacks.)", default=False)
        parser.add_argument("--libversion",         dest="libversion",        action="store_true",                  help="Print the library version and exit", default=False)
        parser.add_argument("--version",            dest="version",           action="store_true",                  help="Print the main script version and exit", default=False)
        parser.add_argument("--dry-run",            dest="dry_run",           action="store_true",                  help="Do not save any action", default=False)
        mgroup = parser.add_mutually_exclusive_group(required=True)
        mgroup.add_argument("--baseline",           dest="baselineID",        metavar="BASE_ID",   nargs='?',       help="Set baseline version in migration table", default=argparse.SUPPRESS)
        mgroup.add_argument("--upgrade",            dest="upgradeID",         metavar="UP_ID",     nargs='?',       help="Sequential upgrade to version", default=argparse.SUPPRESS)
        mgroup.add_argument("--downgrade",          dest="downgradeID",       metavar="DOWN_ID",   nargs='?',       help="Sequential downgrade to version", default=argparse.SUPPRESS)
        mgroup.add_argument("--info",               dest="infoID",            metavar="INFO_ID",   nargs='?',       help="Get the current version information", default=argparse.SUPPRESS)
        mgroup.add_argument("--baseline-info",      dest="getBaselineInfo",   action="store_true",                  help="Get the baseline version information", default=False)
        mgroup.add_argument("--migration-log",      dest="migrationLog",      action="store_true",                  help="Output migration log from database.", default=False)
        mgroup.add_argument("--verify",             dest="verifyID",          metavar="VERIFY_ID"  nargs='?',       help="Verify the schema is at specified version")
        mgroup.add_argument("--create",             dest="create",            metavar="FILE_NAME", nargs='?',       help="Create a new migration file. Specify file as <file>.sql or <file>.py", default=argmarse.SUPPRESS)
        mgroup.add_argument("--delete",             dest="delete",            metavar="DEL_ID",                     help="Delete an unapplied migration")
        mgroup.add_argument("--export-log",         dest="export",            metavar="LOG_FILE_NAME",              help="Export migration log as sql to file")
        
        return parser
    # End init_args


    def main():
        """Main function for command-line execution."""
        parser = init_args()
        try:
            if '--libversion' in sys.argv:
                print("pydbovlve module version {}".format(pydbvolve.__VERSION_STRING__))
                return 0
            
            if '--version' in sys.argv:
                print("version {}".format(__VERSION_STRING__))
                return 0
                
            args = parser.parse_args()
        except:
            return -1
        
        if args.libversion:
            print("pydbovlve module version {}".format(pydbvolve.__VERSION_STRING__))
            return 0
        
        if args.version:
            print("version {}".format(__VERSION_STRING__))
            return 0
        
        if hasattr(args, 'baselineID'):
            action = 'baseline'
            version = args.baselineVersion or pydbvolve.CURRENT_VERSION
        elif hasattr(args, 'upgradeID'):
            action = 'upgrade'
            version = args.upgradeVersion or pydbvolve.LATEST_VERSION
        elif hasattr(args, 'downgradeID'):
            action = 'downgrade'
            version = args.downgradeVersion or pydbvolve.BASELINE_VERSION
        elif hasattr(args, 'infoID'):
            action = 'info'
            version = pydbvolve.CURRENT_VERSION
        elif args.getBaselineInfo:
            action = 'info'
            version = pydbvolve.BASELINE_VERSION
        elif args.migrationLog:
            action = 'log'
            version = 'all'
        elif hasattr(args, 'verifyID'):
            action = 'verify'
            version = args.verifyID or pydbvolve.CURRENT_VERSION
        
        if not action:
			print("No action set", file=sys.stderr)
			return 0
        
        sequential = args.sequential
        verbose = args.verbose
        dry_run = args.dry_run
        
        rc = pydbvolve.run_migration(args.configFileName, action, version, sequential, verbose, dry_run, chatty=True)
        
        return rc
    # End main
    
    # Execute!
    try:
        rc = main()
        if rc != 0:
            print("Exiting with {}".format(rc), file=sys.stderr)
        else:
            print("Done.")
        
        sys.exit(rc)
    except Exception as e:
        print("ERROR:: Unhandled excaption {}: {}".format(type(e).__name__, e), file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        sys.exit(254)


